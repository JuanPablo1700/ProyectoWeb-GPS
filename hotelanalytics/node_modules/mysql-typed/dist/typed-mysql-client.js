"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TypedMySQLClient = void 0;
const snake_case_1 = require("snake-case");
const database_utils_1 = require("./database-utils");
class TypedMySQLClient {
    constructor(pool, logger) {
        this.pool = pool;
        this.logger = logger;
        this.client = null;
    }
    async closeSession() {
        if (this.client) {
            this.client.release();
        }
    }
    async crudGetAll(table, filters, notSingleError) {
        const { filter, filterValues } = (0, database_utils_1.getFilters)(filters);
        const result = await this.query(`SELECT * FROM "app"."${table}" ${filter}`, filterValues);
        if (notSingleError) {
            return (0, database_utils_1.exactlyOneResult)(result.rows, notSingleError);
        }
        return result.rows;
    }
    async crudGet(table, fields, filters, notSingleError) {
        const { filter, filterValues } = (0, database_utils_1.getFilters)(filters);
        const result = await this.query(({ sf }) => `
      SELECT ${sf(table, fields, table)}
      FROM "app"."${table}"
      ${filter}
    `, filterValues);
        if (notSingleError) {
            return (0, database_utils_1.exactlyOneResult)(result.rows, notSingleError);
        }
        return result.rows;
    }
    async crudBulkInsert(table, insert, returns) {
        const [keys, values, realValues] = (0, database_utils_1.createBulkInsert)(insert);
        if (returns) {
            const returnStatement = (returns || []).map(key => (0, snake_case_1.snakeCase)(key.toString())).join(',');
            const result = await this.query(`INSERT INTO "app".${table}(${keys}) VALUES ${values} RETURNING ${returnStatement};`, realValues);
            return result.rows;
        }
        else {
            await this.query(`INSERT INTO "app".${table}(${keys}) VALUES ${values}`, realValues);
        }
    }
    async crudInsert(table, insert, returns) {
        const [keys, values, realValues] = (0, database_utils_1.createInsert)((0, database_utils_1.transformValues)(insert));
        if (returns) {
            const returnStatement = returns.map(key => (0, snake_case_1.snakeCase)(key.toString())).join(',');
            return await this.one(`INSERT INTO "app".${table}(${keys}) VALUES (${values}) RETURNING ${returnStatement};`, realValues, new Error());
        }
        else {
            await this.query(`INSERT INTO "app".${table}(${keys}) VALUES (${values})`, realValues);
        }
    }
    /**
     * @param table
     * @param update
     * @param filters
     * @param error
     * @returns Void
     */
    async crudUpdate(table, update, filters, error) {
        if (Object.keys(update).length === 0) {
            return;
        }
        const { filter, filterValues } = (0, database_utils_1.getFilters)(filters);
        const [keys, values, realValues] = (0, database_utils_1.createInsert)((0, database_utils_1.transformValues)(update), filterValues.length);
        const result = await this.query(`
        UPDATE "app".${table}
        SET (${keys}) = row(${values})
        ${filter}
    `, [...filterValues, ...realValues]);
        if (result.rows.length !== 1 && error) {
            throw error;
        }
    }
    async crudDelete(table, filters, returns = [], notSingleError) {
        const { filter, filterValues } = (0, database_utils_1.getFilters)(filters);
        if (returns.length > 1) {
            const result = await this.query(`DELETE FROM "app"."${table}" RETURNING ${returns.join(',')}, ${filter}`, filterValues);
            if (notSingleError) {
                return (0, database_utils_1.exactlyOneResult)(result.rows, notSingleError);
            }
            return result.rows;
        }
        const result = await this.query(`DELETE FROM "app"."${table}" ${filter}`, filterValues);
        if (notSingleError && result.rows.length !== 1) {
            (0, database_utils_1.exactlyOneResult)(result.rows, notSingleError);
        }
    }
    async debugQuery(statement, values = []) {
        const result = await this.query(statement, values, 'debug');
        return result.rows;
    }
    async one(statement, values = [], error) {
        const result = await this.query(statement, values);
        return (0, database_utils_1.exactlyOneResult)(result.rows, error);
    }
    async many(statement, values = []) {
        const result = await this.query(statement, values);
        return result.rows;
    }
    createFields(table, fields, alias = table) {
        const r = fields.reduce((r, field) => {
            r.push(`'${field}'`);
            r.push(`"${alias}".${(0, snake_case_1.snakeCase)(field)}`);
            return r;
        }, []);
        return r.join(',');
    }
    selectFields(table, fields, alias = table) {
        const r = fields.reduce((r, field) => {
            r.push(`"${alias}".${(0, snake_case_1.snakeCase)(field)}`);
            return r;
        }, []);
        return r.join(',');
    }
    async transaction(fn) {
        if (this.client) {
            return await fn();
        }
        this.client = await this.pool.getClient();
        try {
            await this.query('BEGIN;');
            const result = await fn();
            await this.query('COMMIT;');
            return result;
        }
        catch (e) {
            await this.query('ROLLBACK');
            throw e;
        }
        finally {
            this.client?.release();
            this.client = null;
        }
    }
    async query(statement, values = [], debug) {
        let query = typeof statement === 'string' ? statement : statement({
            cf: this.createFields,
            sf: this.selectFields
        });
        query = query.replace(/^\s*[\r\n]/gm, '');
        if (debug) {
            this.logger.info(`\nExecuting:\n  Query: ${query}\n  Values:\n ${values}\n'`);
        }
        if (!this.client) {
            return await this.transaction(async () => this.query(query, values, debug));
        }
        const start = Date.now();
        try {
            const [rows, meta] = await this.client?.query(query, values);
            if (debug) {
                const duration = Date.now() - start;
                this.logger.info(`executed query ${JSON.stringify({
                    query,
                    duration,
                    rows: meta
                })}`);
            }
            return { rows, meta };
        }
        catch (err) {
            if (err.message.includes('user_auth_email_key')) {
                this.logger.error(`Error inserting data with duplicated email: ${JSON.stringify(values)}`);
            }
            else {
                const errorId = Math.random().toString().substr(2);
                console.error(`Error ${errorId} running statement:`, query, 'with values', JSON.stringify(values));
                this.logger.error(`Error running sql statement ${errorId} ${err.message}`, { errorId });
            }
            throw err;
        }
    }
}
exports.TypedMySQLClient = TypedMySQLClient;
//# sourceMappingURL=typed-mysql-client.js.map