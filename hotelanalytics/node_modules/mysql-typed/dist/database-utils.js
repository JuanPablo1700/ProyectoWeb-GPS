"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createFilters = exports.exactlyOneResult = exports.transformValues = exports.createInsert = exports.createBulkInsert = exports.getFilters = void 0;
/* eslint-disable quotes */
const snake_case_1 = require("snake-case");
const getFilters = (filters) => {
    if (filters instanceof Array) {
        return (0, exports.createFilters)({ filters });
    }
    else {
        return (0, exports.createFilters)({ filters: Object.entries(filters).map(([field, value], index) => ({ value, field, operator: 'eq', conditionType: index !== 0 ? 'AND' : undefined })) });
    }
};
exports.getFilters = getFilters;
// This is definately not production ready
const createBulkInsert = (bulk) => {
    let i = 1;
    const keys = [];
    const values = [];
    const realValues = bulk.map((data) => {
        data = (0, exports.transformValues)(data);
        Object.keys(data).forEach((key) => {
            if (!keys.includes(key)) {
                keys.push(key);
            }
        });
        values.push(`(${keys.map(() => `$${i++}`).join(',')})`);
        return Object.keys(data).map((k) => data[k]);
    });
    return [`"${keys.map((k) => (0, snake_case_1.snakeCase)(k)).join('","')}"`, values.join(','), realValues.reduce((r, v) => [...r, ...v])];
};
exports.createBulkInsert = createBulkInsert;
const createInsert = (data, offset = 0) => {
    const keys = Object.keys(data).filter((k) => data[k] !== undefined);
    const values = keys.map((k, i) => '?');
    const realValues = keys.map((k) => data[k]);
    return [`"${keys.map((k) => (0, snake_case_1.snakeCase)(k)).join('","')}"`, values.join(','), realValues];
};
exports.createInsert = createInsert;
// eslint-disable-next-line
const transformValues = (from) => {
    return Object.keys(from).reduce((r, k) => {
        const value = from[k];
        if (typeof value === 'number' || typeof value === 'string' || value === null || value === Date) {
            r[k] = value;
        }
        else if (value instanceof Array && k === 'tags') {
            r[k] = `{ ${value.join(',')}}`;
        }
        else {
            r[k] = JSON.stringify(value);
        }
        return r;
    }, {});
};
exports.transformValues = transformValues;
const exactlyOneResult = (result, Err) => {
    if (result.length !== 1) {
        throw Err;
    }
    return result[0];
};
exports.exactlyOneResult = exactlyOneResult;
const operatorToMysql = new Map([
    ['gt', '>'],
    ['gte', '>='],
    ['lt', '<'],
    ['lte', '<='],
    ['eq', '='],
    ['ne', '!='],
    ['on', '='],
    ['after', '>'],
    ['before', '<']
]);
const manageFilters = (expressions) => {
    return expressions.reduce((result, expression) => {
        if (expression.conditionType) {
            result.push({ conditionType: expression.conditionType });
        }
        if (expression.expressions) {
            return [...result, { grouping: '(' }, ...manageFilters(expression.expressions), { grouping: ')' }];
        }
        else {
            const { field, value, operator } = expression;
            const parts = field.split('.');
            if (parts.length === 1) {
                result.push({ operator, field, value });
            }
            else {
                let table = parts[0].replace(/s$/, '');
                const actualField = parts.pop();
                result.push({ table, operator, field: actualField, value });
            }
        }
        return result;
    }, []);
};
const createFilters = (data, freeTextFields = [], includeWhere = true, valueOffset = 0) => {
    const limit = data.limit || 1000;
    const offset = data.offset || 0;
    let sort = '';
    if (data.sort) {
        const parts = data.sort.key.split('.');
        let table = '';
        if (parts.length > 1) {
            // TODO: This logic should be in client.
            table = `"${parts[0]}".`;
        }
        const field = parts.pop();
        sort = `ORDER BY ${table}${(0, snake_case_1.snakeCase)(field)} ${data.sort.order}`;
    }
    let cleanFilters = manageFilters(data.filters || []);
    if (data.freeText && data.freeText.trim()) {
        const freeTextFilters = freeTextFields.map((field, index) => ({ conditionType: index === 0 ? undefined : 'OR', field, operator: 'contains', value: data.freeText }));
        let filters = [];
        if (data.filters && data.filters.length > 0) {
            filters = data.filters;
        }
        cleanFilters = manageFilters([...filters, { conditionType: data.filters?.length ? 'AND' : undefined, expressions: freeTextFilters }]);
    }
    else {
        cleanFilters = manageFilters(data.filters || []);
    }
    const filterValues = [];
    let filter = '';
    if (cleanFilters && cleanFilters.length > 0) {
        const filters = cleanFilters.map(({ grouping, conditionType = '', operator, table, field, value }) => {
            if (grouping) {
                return grouping;
            }
            if (conditionType && field === undefined) {
                return conditionType;
            }
            const t = table ? `"${table}".` : '';
            const column = `${t}"${(0, snake_case_1.snakeCase)(field)}"`;
            if (operator === 'includes' || operator === 'excludes') {
                filterValues.push(value);
                return `${conditionType} $${valueOffset + filterValues.length} ${operator === 'includes' ? '=' : '!='} ANY (${t}"${(0, snake_case_1.snakeCase)(field)}")`;
            }
            if (operatorToMysql.has(operator)) {
                filterValues.push(value);
                return `${conditionType} ${column} ${operatorToMysql.get(operator)} $${valueOffset + filterValues.length}`;
            }
            if (conditionType) {
                return conditionType;
            }
            return undefined;
        }).filter(v => !!v);
        if (filters.length > 0) {
            filter = `${includeWhere ? 'WHERE ' : ''}${filters.join(' ')}`;
        }
    }
    return { limit, offset, sort, filter, filterValues };
};
exports.createFilters = createFilters;
//# sourceMappingURL=database-utils.js.map