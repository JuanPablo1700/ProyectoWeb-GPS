import { FilterSubExpressions } from '@vramework/generic/dist/filter';
import { TypedMySQLPool } from '.';
import { Logger, QueryInterface, ValueTypes } from './database-utils';
export declare class TypedMySQLClient<Tables extends {
    [key: string]: any;
}, CustomTypes> {
    private pool;
    private logger;
    private client;
    constructor(pool: TypedMySQLPool<Tables, {}>, logger: Logger);
    closeSession(): Promise<void>;
    /**
     *
     * @param table
     * @param fields
     * @param filters
     */
    crudGetAll<N extends keyof Tables, T extends Tables[N]>(table: N, filters: Partial<T> | FilterSubExpressions): Promise<T[]>;
    crudGetAll<N extends keyof Tables, T extends Tables[N]>(table: N, filters: Partial<T> | FilterSubExpressions, notSingleError: Error): Promise<T>;
    /**
     *
     * @param table
     * @param fields
     * @param filters
     */
    crudGet<N extends keyof Tables, T extends Tables[N], F extends readonly (keyof T)[]>(table: N, fields: F, filters: Partial<T> | FilterSubExpressions): Promise<Pick<T, typeof fields[number]>[]>;
    crudGet<N extends keyof Tables, T extends Tables[N], F extends readonly (keyof T)[]>(table: N, fields: F, filters: Partial<T> | FilterSubExpressions, notSingleError: Error): Promise<Pick<T, typeof fields[number]>>;
    /**
     *
     * @param table
     * @param insert
     */
    crudBulkInsert<N extends keyof Tables, T extends Tables[N]>(table: N, insert: Partial<Record<keyof T, ValueTypes | CustomTypes>>[]): Promise<void>;
    crudBulkInsert<N extends keyof Tables, T extends Tables[N], F extends readonly (keyof T)[]>(table: N, insert: Partial<Record<keyof T, ValueTypes | CustomTypes>>[], returns: readonly (keyof T)[]): Promise<Record<keyof T, any>[]>;
    /**
     *
     * @param table
     * @param insert
     */
    crudInsert<N extends keyof Tables, T extends Tables[N]>(table: N, insert: Partial<Record<keyof T, ValueTypes | CustomTypes>>, returns?: []): Promise<void>;
    crudInsert<N extends keyof Tables, T extends Tables[N], F extends readonly (keyof T)[]>(table: N, insert: Partial<Record<keyof T, ValueTypes | CustomTypes>>, returns: F): Promise<Pick<T, typeof returns[number]>>;
    /**
     * @param table
     * @param update
     * @param filters
     * @param error
     * @returns Void
     */
    crudUpdate<N extends keyof Tables, T extends Tables[N]>(table: N, update: Partial<T>, filters: Partial<T>, error?: Error): Promise<void>;
    /**
     *
     * @param table
     * @param filters
     * @param notSingleError
     * @returns
     */
    crudDelete<N extends keyof Tables, T extends Tables[N], F extends readonly (keyof T)[]>(table: N, filters: Partial<T>): Promise<void>;
    crudDelete<N extends keyof Tables, T extends Tables[N], F extends readonly (keyof T)[]>(table: N, filters: Partial<T>, returns: F, notSingleError: Error): Promise<Pick<T, typeof returns[number]>>;
    crudDelete<N extends keyof Tables, T extends Tables[N], F extends readonly (keyof T)[]>(table: N, filters: Partial<T>, returns: F | [], notSingleError: Error): Promise<void | Pick<T, typeof returns[number]>>;
    debugQuery<T>(statement: QueryInterface<Tables>, values?: Array<ValueTypes>): Promise<T[]>;
    one<T>(statement: QueryInterface<Tables>, values: ValueTypes[] | undefined, error: Error): Promise<T>;
    many<T>(statement: QueryInterface<Tables>, values?: Array<ValueTypes>): Promise<T[]>;
    createFields<N extends keyof Tables, T extends Tables[N], F extends readonly (keyof T)[]>(table: N, fields: F, alias?: string): string;
    private selectFields;
    transaction<T>(fn: (() => Promise<T>)): Promise<T>;
    query<T>(statement: QueryInterface<Tables>, values?: Array<ValueTypes>, debug?: 'debug'): Promise<{
        rows: T[];
        meta: any;
    }>;
}
