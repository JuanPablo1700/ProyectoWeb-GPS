import { FilterSubExpressions } from '@vramework/generic/dist/filter';
import { PoolOptions, Pool, PoolConnection } from 'mysql2/promise';
import { Logger, QueryInterface, ValueTypes } from './database-utils';
export declare class TypedMySQLPool<Tables extends {
    [key: string]: any;
}, CustomTypes = never> {
    private poolOptions;
    private logger;
    pool: Pool;
    client: PoolConnection;
    constructor(poolOptions: PoolOptions, logger: Logger);
    init(): Promise<void>;
    getClient(): Promise<PoolConnection>;
    crudGetAll<N extends keyof Tables, T extends Tables[N]>(table: N, filters: Partial<T> | FilterSubExpressions): Promise<T[]>;
    crudGetAll<N extends keyof Tables, T extends Tables[N]>(table: N, filters: Partial<T> | FilterSubExpressions, notSingleError: Error): Promise<T>;
    crudGet<N extends keyof Tables, T extends Tables[N], F extends readonly (keyof T)[]>(table: N, fields: F, filters: Partial<T> | FilterSubExpressions): Promise<Pick<T, typeof fields[number]>[]>;
    crudGet<N extends keyof Tables, T extends Tables[N], F extends readonly (keyof T)[]>(table: N, fields: F, filters: Partial<T> | FilterSubExpressions, notSingleError: Error): Promise<Pick<T, typeof fields[number]>>;
    one<T>(statement: QueryInterface<Tables>, values: ValueTypes[] | undefined, error: Error): Promise<T>;
    many<T>(statement: QueryInterface<Tables>, values?: Array<ValueTypes>): Promise<T[]>;
    query<T>(statement: QueryInterface<Tables>, values?: any[]): Promise<{
        rows: T[];
        meta: any;
    }>;
    close(): Promise<void>;
    private checkConnection;
    createFields<N extends keyof Tables, T extends Tables[N], F extends readonly (keyof T)[]>(table: N, fields: F, alias?: string): string;
    private selectFields;
}
