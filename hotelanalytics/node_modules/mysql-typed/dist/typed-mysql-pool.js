"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TypedMySQLPool = void 0;
const promise_1 = require("mysql2/promise");
const database_utils_1 = require("./database-utils");
const snake_case_1 = require("snake-case");
class TypedMySQLPool {
    constructor(poolOptions, logger) {
        this.poolOptions = poolOptions;
        this.logger = logger;
        this.logger.info(`Using db host: ${poolOptions.host}`);
        this.pool = (0, promise_1.createPool)(poolOptions);
    }
    async init() {
        this.client = await this.pool.getConnection();
        await this.checkConnection();
        await this.client.release();
    }
    async getClient() {
        return this.pool.getConnection();
    }
    async crudGetAll(table, filters, notSingleError) {
        const { filter, filterValues } = (0, database_utils_1.getFilters)(filters);
        const result = await this.query(`SELECT * FROM "${table}" ${filter}`, filterValues);
        if (notSingleError) {
            return (0, database_utils_1.exactlyOneResult)(result.rows, notSingleError);
        }
        return result.rows;
    }
    async crudGet(table, fields, filters, notSingleError) {
        const { filter, filterValues } = (0, database_utils_1.getFilters)(filters);
        const result = await this.query(({ sf }) => `
      SELECT ${sf(table, fields)}
      FROM "${table}"
      ${filter}
    `, filterValues);
        if (notSingleError) {
            return (0, database_utils_1.exactlyOneResult)(result.rows, notSingleError);
        }
        return result.rows;
    }
    async one(statement, values = [], error) {
        const result = await this.query(statement, values);
        return (0, database_utils_1.exactlyOneResult)(result.rows, error);
    }
    async many(statement, values = []) {
        const result = await this.query(statement, values);
        return result.rows;
    }
    async query(statement, values) {
        const query = typeof statement === 'string' ? statement : statement({
            cf: this.createFields,
            sf: this.selectFields
        });
        const [rows, meta] = await this.pool.query(query, values);
        return { rows, meta };
    }
    async close() {
        this.pool.end();
    }
    async checkConnection() {
        try {
            const result = await this.query('SHOW server_version;');
            this.logger.info(`Postgres server version is: ${result.rows[0].serverVersion}`);
        }
        catch (e) {
            console.error(e);
            this.logger.error(`Unable to connect to server with ${this.poolOptions.host}, exiting server`);
            process.exit(1);
        }
    }
    createFields(table, fields, alias) {
        const r = fields.reduce((r, field) => {
            r.push(`'${field}'`);
            r.push(`"${alias}".${(0, snake_case_1.snakeCase)(field)}`);
            return r;
        }, []);
        return r.join(',');
    }
    selectFields(table, fields, alias) {
        const r = fields.reduce((r, field) => {
            r.push(`"${alias}".${(0, snake_case_1.snakeCase)(field)}`);
            return r;
        }, []);
        return r.join(',');
    }
}
exports.TypedMySQLPool = TypedMySQLPool;
//# sourceMappingURL=typed-mysql-pool.js.map