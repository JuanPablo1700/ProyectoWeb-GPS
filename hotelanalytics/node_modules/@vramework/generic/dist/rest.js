"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.del = exports.head = exports.get = exports.patch = exports.post = exports.setAPIKey = exports.setAuthorizationJWT = exports.setAPIPrefix = exports.transformResult = void 0;
let restFetch;
let apiPrefix = '';
let authHeaders = {
    jwt: undefined,
    apiKey: undefined
};
const getHeaders = () => {
    let headers = { 'Content-Type': 'application/json' };
    if (authHeaders.jwt) {
        headers.Authorization = `Bearer ${authHeaders.jwt}`;
    }
    else if (authHeaders.apiKey) {
        headers['X-API-KEY'] = authHeaders.apiKey;
    }
    return headers;
};
const initFetch = async () => {
    if (!restFetch) {
        if (typeof window === 'undefined') {
            const fetch = await Promise.resolve().then(() => __importStar(require('node-fetch')));
            restFetch = fetch.default;
        }
        else {
            restFetch = fetch;
        }
    }
};
const transformResult = (data) => {
    if (data === null) {
        return null;
    }
    if (data instanceof Array) {
        return data.map(exports.transformResult);
    }
    if (typeof data === 'object') {
        return Object.entries(data).reduce((result, [key, value]) => {
            result[key] = (0, exports.transformResult)(value);
            return result;
        }, {});
    }
    if (typeof data === 'string' && /^\d{4}-\d{2}-\d{2}(T\d{2}:\d{2}:\d{2}.\d{3}Z?)?/.test(data)) {
        return new Date(data);
    }
    return data;
};
exports.transformResult = transformResult;
const setAPIPrefix = async (prefix) => {
    apiPrefix = prefix;
};
exports.setAPIPrefix = setAPIPrefix;
const setAuthorizationJWT = (jwt) => {
    authHeaders.jwt = jwt;
};
exports.setAuthorizationJWT = setAuthorizationJWT;
const setAPIKey = (apiKey) => {
    authHeaders.apiKey = apiKey;
};
exports.setAPIKey = setAPIKey;
async function action(method, url, body, hasResponseBody = true) {
    await initFetch();
    const data = JSON.stringify(body);
    try {
        const response = await restFetch(`${apiPrefix}/${url}`, {
            method,
            cache: 'no-cache',
            mode: 'cors',
            credentials: 'include',
            headers: getHeaders(),
            body: data,
        });
        if (response.status >= 400) {
            throw response;
        }
        if (hasResponseBody) {
            const data = await response.json();
            return (0, exports.transformResult)(data);
        }
    }
    catch (e) {
        // This is a 404
        throw e;
    }
}
async function post(url, data, hasResponseBody = true) {
    if (hasResponseBody) {
        return await action('POST', url, data, true);
    }
    await action('POST', url, data, false);
}
exports.post = post;
async function patch(url, data, hasResponseBody = true) {
    if (hasResponseBody) {
        return await action('PATCH', url, data, true);
    }
    await action('PATCH', url, data, false);
}
exports.patch = patch;
async function get(url, query) {
    await initFetch();
    let uri = `${apiPrefix}/${url}`;
    if (query) {
        // removes all the undefined
        const params = new URLSearchParams(JSON.parse(JSON.stringify(query)));
        uri = `${apiPrefix}/${url}?${params}`;
    }
    const response = await restFetch(uri, {
        method: 'GET',
        mode: 'cors',
        credentials: 'include',
        headers: getHeaders()
    });
    if (response.status > 400) {
        throw response;
    }
    try {
        return await response.json();
    }
    catch (e) {
        throw 'Unable to parse json response';
    }
}
exports.get = get;
async function head(url, query) {
    let uri = `${apiPrefix}/${url}`;
    if (query) {
        const params = new URLSearchParams(query);
        uri = `${apiPrefix}/${url}?${params}`;
    }
    const response = await restFetch(uri, {
        method: 'HEAD',
        mode: 'cors',
        credentials: 'include',
        headers: getHeaders()
    });
    return response.status;
}
exports.head = head;
async function del(url, query) {
    await initFetch();
    let uri = `${apiPrefix}/${url}`;
    if (query) {
        // removes all the undefined
        const params = new URLSearchParams(JSON.parse(JSON.stringify(query)));
        uri = `${apiPrefix}/${url}?${params}`;
    }
    const response = await restFetch(uri, {
        method: 'DELETE',
        mode: 'cors',
        credentials: 'include',
        headers: getHeaders()
    });
    if (response.status > 400) {
        throw 'Didnt happen';
    }
}
exports.del = del;
//# sourceMappingURL=rest.js.map